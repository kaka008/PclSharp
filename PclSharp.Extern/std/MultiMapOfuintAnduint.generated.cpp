// Code generated by a template
#pragma once
#include "..\export.h"
#include <map>

using namespace std;

typedef multimap<uint32_t, uint32_t> vectorType;
typedef vectorType::iterator vit;

#ifdef __cplusplus  
extern "C" {  
#endif

EXPORT(vectorType*) std_multimap_uintanduint_ctor()
{
	return new multimap<uint32_t, uint32_t>();
}

EXPORT(void) std_multimap_uintanduint_delete(multimap<uint32_t, uint32_t>** ptr)
{
	delete *ptr;
	*ptr = NULL;
}

EXPORT(vit*) std_multimap_uintanduint_iter_ctor()
{ return new vit(); }

EXPORT(void) std_multimap_uintanduint_iter_del(vit** ptr)
{
	delete *ptr;
	*ptr = NULL;
}

EXPORT(void) std_multimap_uintanduint_begin(multimap<uint32_t, uint32_t>* ptr, vit* iter)
{ *iter = ptr->begin(); }

EXPORT(void) std_multimap_uintanduint_end(multimap<uint32_t, uint32_t>* ptr, vit* iter)
{ *iter = ptr->end(); }

EXPORT(void) std_multimap_uintanduint_upperBound(multimap<uint32_t, uint32_t>* ptr, uint32_t key, vit* iter)
{ *iter = ptr->upper_bound(key); }

EXPORT(void) std_multimap_uintanduint_equal_range(multimap<uint32_t, uint32_t>* ptr, uint32_t key, vit* first, vit* second)
{
	auto range = ptr->equal_range(key);
	*first = range.first;
	*second = range.second;
}

EXPORT(int) std_multimap_uintanduint_size(multimap<uint32_t, uint32_t>* ptr)
{ return ptr->size(); }

EXPORT(int) std_multimap_uintanduint_iter_equals(vit* ptr, vit* other)
{ return *ptr == *other; }

EXPORT(void) std_multimap_uintanduint_iter_assign(vit* ptr, vit* other)
{ *ptr = *other; }

EXPORT(uint32_t) std_multimap_uintanduint_iter_first(const vit* ptr)
{ return ptr->operator->()->first; }
EXPORT(uint32_t) std_multimap_uintanduint_iter_second(const vit* ptr)
{ return ptr->operator->()->second; }

EXPORT(void) std_multimap_uintanduint_iter_pp(vit* ptr)
{ *ptr = ptr->operator++(); }

#ifdef __cplusplus  
}
#endif
