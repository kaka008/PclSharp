<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	manager.Process(true);
#>
namespace PclSharp.Search
{
	public abstract class KdTree<PointT> : Search<PointT>
	{
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin)
{ 
	var classname = ClassName.ToLower();
	var classFunc = "search_kdtree_" + classname;
	
	var cppWrapper = "KdTree<"+cppin+">";

	manager.StartNewFile("KdTreeOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
#>
using System;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;

namespace PclSharp.Search
{
	public static partial class Invoke
	{
		<#= i.Func("IntPtr", "ctor", "bool sorted") #>
		<#= i.Delete() #>

		//methods
		<#=i.FuncI("setInputCloud", "IntPtr cloud")#>

		//properties
		<#=i.Prop("SortedResults", "bool")#>
	}

    public class KdTreeOf<#=ClassName#> : KdTree<<#=csin#>>
    {
		public override bool SortedResults
		{
			<#=i.InvokeP("SortedResults", "bool")#>
		}

		public KdTreeOf<#=ClassName#>(bool sorted = true)
		{
			_ptr = <#=i.Invoke("ctor", "sorted")#>;
		}

        public override void SetInputCloud(PointCloud<<#=csin#>> cloud)
		{
			<#=i.InvokeI("setInputCloud", "cloud")#>;
		}

		protected override void DisposeObject()
		{
			<#=i.DeleteI()#>;
		}
    }
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\search\\KdTreeOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include <pcl/search/kdtree.h>

using namespace pcl::search;
using namespace std;

typedef pcl::<#=cppin#> <#=cppin#>;
typedef <#=cppWrapper#> search_t;
typedef boost::shared_ptr<pcl::PointCloud<<#=cppin#>>> boost_cloud;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("search_t*", "ctor", "int sorted")#>
{
	return new search_t(sorted);
}

<#=i.Export("void", "delete", "search_t** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setInputCloud", "pcl::PointCloud<cppin>* cloud")#>
{
	ptr->setInputCloud(boost_cloud(boost_cloud(), cloud));
}

<#=i.ExportP("SortedResults", "int")#>

#ifdef __cplusplus  
}
#endif  
<#+ i.Dispose(); manager.EndBlock(false); }#>