<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<#
	var manager = Manager.Create(Host, GenerationEnvironment);

	outputClass(manager, "uint", "uint", "uint32_t", "uint32_t");

	manager.Process(true);
#>
// Code generated by a template
using System;
using System.Collections;
using System.Collections.Generic;

namespace PclSharp.Std
{
	public abstract class MultiMap<TKey, TValue> : UnmanagedObject, IEnumerable<KeyValuePair<TKey, TValue>>
	{
		protected bool _suppressDispose;

		public abstract IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator()
			=> GetEnumerator();
	}
}
<#+
void outputClass(Manager manager, string csKey, string csValue, string cppKey, string cppValue) 
{
	var ClassName = csKey + "And" + csValue;

	var classname = ClassName.ToLower();
	var classFunc = "std_multimap_" + classname;

	var cppVector = "multimap<"+cppKey+", "+cppValue+">";

	manager.StartNewFile("MultiMapOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csKey, cppVector);
	i.Var("csKey", csKey);
	i.Var("csValue", csValue);
	i.Var("cppKey", cppKey);
	i.Var("cppValue", cppValue);
	i.Var("cppVector", cppVector);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace PclSharp.Std
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>

		<#=i.FuncI("void", "begin", "IntPtr iter")#>
		<#=i.FuncI("void", "end", "IntPtr iter")#>
		<#=i.FuncI("void", "upperBound", "csKey key, IntPtr iter")#>
		<#=i.FuncI("void", "equal_range", "csKey key, IntPtr first, IntPtr second")#>

		<#=i.FuncI("int", "size", "")#>

		<#=i.Func("IntPtr", "iter_ctor", "")#>
		<#=i.Func("void", "iter_del", "ref IntPtr iter")#>

		<#=i.Func("void", "iter_assign", "IntPtr ptr, IntPtr other")#>
		<#=i.Func("bool", "iter_equals", "IntPtr ptr, IntPtr other")#>
		<#=i.Func("csKey", "iter_first", "IntPtr ptr")#>
		<#=i.Func("csValue", "iter_second", "IntPtr ptr")#>
		<#=i.Func("void", "iter_pp", "IntPtr ptr")#>
	}

	public class MultiMapOf<#=ClassName#> : MultiMap<<#=csKey#>, <#=csValue#>>
	{
		public int Count
			=> <#=i.InvokeI("size")#>;

		public MultiMapOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public override IEnumerator<KeyValuePair<<#=csKey#>, <#=csValue#>>> GetEnumerator()
		{
			using(var begin = Begin())
			using(var end = End())
			{
				for(; !begin.Equals(end); begin.Increment())
				{
					yield return new KeyValuePair<<#=csKey#>, <#=csValue#>>(begin.Key, begin.Value);
				}
			}
		}

		public Iterator Begin()
		{
			var begin = new Iterator();
			<#=i.InvokeI("begin", "begin")#>;
			return begin;
		}

		public Iterator End()
		{
			var end = new Iterator();
			<#=i.InvokeI("end", "end")#>;
			return end;
		}

		public void UpperBound(<#=csKey#> key, Iterator it)
			=> <#=i.InvokeI("upperBound", "key, it")#>;

		public IEnumerable<KeyValuePair<<#=csKey#>, <#=csValue#>>>  EqualRange(<#=csKey#> key)
		{
			using (var begin = new Iterator())
			using(var end = new Iterator())
			{
				<#=i.InvokeI("equal_range", "key, begin, end")#>;

				for(; !begin.Equals(end); begin.Increment())
					yield return new KeyValuePair<<#=csKey#>, <#=csValue#>>(begin.Key, begin.Value);
			}
		}
		
		protected override void DisposeObject()
		{
			if (_suppressDispose)
				return;
			<#= i.DeleteI() #>;
		}

		public class Iterator : UnmanagedObject
		{
			public Iterator()
			{
				_ptr = <#=i.Invoke("iter_ctor")#>;
			}

			public Iterator(IntPtr ptr)
			{
				_ptr = ptr;
			}

			public bool Equals(Iterator other)
				=> <#=i.Invoke("iter_equals", "_ptr, other")#>;

			//makes this iterator equal to the other iterator
			public void SetTo(Iterator other)
				=> <#=i.Invoke("iter_assign", "_ptr, other")#>;

			public <#=csKey#> Key
				=> <#=i.Invoke("iter_first", "_ptr")#>;

			public <#=csValue#> Value
				=> <#=i.Invoke("iter_second", "_ptr")#>;

			public void Increment()
				=> <#=i.Invoke("iter_pp", "_ptr")#>;

			protected override void DisposeObject()
			{
				<#=i.Invoke("iter_del", "ref _ptr")#>;
			}
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\std\\MultiMapOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"
#include <map>

using namespace std;

typedef <#= cppVector #> vectorType;
typedef vectorType::iterator vit;

#ifdef __cplusplus  
extern "C" {  
#endif

<#= i.Export("vectorType*", "ctor", "") #>
{
	return new <#=cppVector#>();
}

<#=i.Export("void", "delete", "cppVector** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.Export("vit*", "iter_ctor", "")#>
{ return new vit(); }

<#=i.Export("void", "iter_del", "vit** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "begin", "vit* iter")#>
{ *iter = ptr->begin(); }

<#=i.ExportI("void", "end", "vit* iter")#>
{ *iter = ptr->end(); }

<#=i.ExportI("void", "upperBound", "cppKey key, vit* iter")#>
{ *iter = ptr->upper_bound(key); }

<#=i.ExportI("void", "equal_range", "cppKey key, vit* first, vit* second")#>
{
	auto range = ptr->equal_range(key);
	*first = range.first;
	*second = range.second;
}

<#=i.ExportI("int", "size", "")#>
{ return ptr->size(); }

<#=i.Export("int", "iter_equals", "vit* ptr, vit* other")#>
{ return *ptr == *other; }

<#=i.Export("void", "iter_assign", "vit* ptr, vit* other")#>
{ *ptr = *other; }

<#=i.Export("cppKey", "iter_first", "const vit* ptr")#>
{ return ptr->operator->()->first; }
<#=i.Export("cppValue", "iter_second", "const vit* ptr")#>
{ return ptr->operator->()->second; }

<#=i.Export("void", "iter_pp", "vit* ptr")#>
{ *ptr = ptr->operator++(); }

#ifdef __cplusplus  
}
#endif
<#+ manager.EndBlock(false); } #>