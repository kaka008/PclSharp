<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);

	outputClass(manager, "Int", "int", "int", new VectorParms());
	outputClass(manager, "UInt", "uint", "uint32_t", new VectorParms());
	outputClass(manager, "Byte", "byte", "unsigned char", new VectorParms());
	outputClass(manager, "Float", "float", "float", new VectorParms());

	var pointParms= new VectorParms
	{
		Namespaces = new[]{"System.Numerics", "PclSharp.Struct"},
		Includes = new[]{"pcl\\point_types.h"},
		CppNamespaces = new[]{"pcl"},
		align = true,
	};
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ", pointParms);
	outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA", pointParms);
	outputClass(manager, "XYZL", "PointXYZL", "PointXYZL", pointParms);
	outputClass(manager, "Normal", "Normal", "Normal", pointParms);


	manager.Process(true);
#>
// Code generated by a template
using System;
using System.Collections;
using System.Collections.Generic;

namespace PclSharp.Std
{
	public abstract class Vector<T> : UnmanagedObject, IList<T>
	{
		public abstract T this[int index]{ get; set; }

        public abstract int Count { get; }

        public bool IsReadOnly => false;

        public abstract void Add(T item);

        public abstract void Clear();

        public abstract void CopyTo(T[] array, int arrayIndex);
        
        public abstract void Insert(int index, T item);

		public abstract T[] ToArray();

		public abstract void Resize(int size);

		public abstract void At(int idx, ref T value);

		public bool Contains(T item)
		{ throw new NotImplementedException(); }

		public int IndexOf(T item)
		{ throw new NotImplementedException(); }

        public bool Remove(T item)
		{ throw new NotImplementedException(); }

        public void RemoveAt(int index)
		{ throw new NotImplementedException(); }

		public virtual IEnumerator<T> GetEnumerator()
			=> ((IEnumerable<T>)ToArray()).GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();
	}
}
<#+
void outputClass(Manager manager, string ClassName, string csClass, string cppClass, VectorParms parms) 
{
	var classname = ClassName.ToLower();
	var classFunc = "std_vector_" + classname;

	var cppVector = parms.cppVector;

	if (cppVector== null)	
	 cppVector = "vector<"+cppClass+">";

	manager.StartNewFile("VectorOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppVector);
	i.Var("cppClass", cppClass);
	i.Var("cppVector", cppVector);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
<#= string.Join("", parms.Namespaces.Select(s => "using " + s + ";\r\n")) #>

namespace PclSharp.Std
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Func("IntPtr", "ctor_count", "int count") #>
		<#= i.Delete() #>
		<#= i.FuncI("at", " UIntPtr idx, ref csClass value") #>
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("void", "resize", "int size") #>
		<#= i.FuncI("add", "csClass value") #>
		<#= i.FuncI("IntPtr", "data", "") #>
		<#= i.FuncI("insert", "IntPtr idx, csClass value") #>
	}

	public unsafe class VectorOf<#= ClassName #> : Vector<<#=csClass#>>
	{	
		private bool _suppressDispose;

		public override int Count => (int)<#=i.InvokeI("size")#>;
		public IntPtr Data => <#=i.InvokeI("data")#>;
		public <#=csClass#>* DataU => (<#=csClass#>*)Data;

		public VectorOf<#= ClassName #>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public VectorOf<#= ClassName #>(int count)
		{
			_ptr = <#=i.Invoke("ctor_count", "count")#>;
		}

		/// <summary>
        /// construct as a copy of the list
        /// </summary>
        /// <param name="list"></param>
		public VectorOf<#= ClassName #>(List<<#=csClass#>> list)
        {
            var arr = list.ToArray();
            _ptr = <#=i.Invoke("ctor_count", "arr.Length")#>;
            
            var dptr = (<#=csClass#>*)Data;
            for(var i = 0; i < arr.Length; i++)
                dptr[i] = arr[i];
        }

		internal VectorOf<#=ClassName#>(IntPtr ptr)
		{
			_suppressDispose = true;
			_ptr = ptr;
		}

		public override void At(int idx, ref <#=csClass#> value)
		{
			<#=i.InvokeI("at", "(UIntPtr)idx, ref value")#>;
		}

		public override <#=csClass#> this[int idx]
        {
            get { return DataU[idx]; }
			set { DataU[idx] = value; }
		}

		public override void Resize(int size)
			=> <#=i.InvokeI("resize", "size")#>;

		public override void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "value")#>;

		public override void CopyTo(<#=csClass#>[] arr, int idx)
		{
            fixed (<#=csClass#>* aptr = arr)
            {
                Unsafe.CopyBlockUnaligned(aptr, DataU, (uint)(sizeof(<#=csClass#>) * Count));
            }
		}

		public override <#=csClass#>[] ToArray()
		{
			var arr = new <#=csClass#>[Count];
            fixed (<#=csClass#>* aptr = arr)
            {
                Unsafe.CopyBlockUnaligned(aptr, DataU, (uint)(sizeof(<#=csClass#>) * arr.Length));
            }

			return arr;
		}

		public override void Clear() => <#=i.InvokeI("clear")#>;

		public override void Insert(int index, <#=csClass#> item)
			=> <#=i.InvokeI("insert", "(IntPtr)index, item")#>;

		public override IEnumerator<<#=csClass#>> GetEnumerator()
		{
			var count = Count;
			for(var i = 0; i < count; i++)
				yield return this[i];
		}

		protected override void DisposeObject()
		{
			if (_suppressDispose)
				return;
			<#= i.DeleteI() #>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\std\\VectorOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"
#include <vector>
<#= string.Join("", parms.Includes.Select(s => "#include \"" + s + "\"\r\n")) #>

using namespace std;
<#= string.Join("", parms.CppNamespaces.Select(s => "using namespace " + s + ";\r\n")) #>

typedef <#= cppVector #> vectorType;

#ifdef __cplusplus  
extern "C" {  
#endif

<#= i.Export("vectorType*", "ctor", "") #>
{
	return new <#=cppVector#>();
}

<#= i.Export("vectorType*", "ctor_count", "int count") #>
{
	return new <#=cppVector#>(count);
}

<#=i.Export("void", "delete", "cppVector** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "at", "size_t idx, cppClass* value")#>
{
	*value = ptr->at(idx);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("void", "resize", "int32_t size")#>
{
	ptr->resize(size);
}

<#=i.ExportI("void", "add", "cppClass value")#>
{
	<#+ if (parms.align) { #>
//the value needs to be aligned to be pushed into the cloud, so do that.
	<#=cppClass#> deref;
	memcpy(&deref, &value, sizeof(<#=cppClass#>));
	ptr->push_back(deref);<#+} else {#>
	ptr->push_back(value);<#+}#>

}

<#=i.ExportI("void", "insert", "ptrdiff_t index, cppClass value")#>
{
	<#+ if (parms.align) { #>
//the value needs to be aligned to be pushed into the cloud, so do that.
	<#=cppClass#> deref;
	memcpy(&deref, &value, sizeof(<#=cppClass#>));
	ptr->insert(ptr->begin()+index, deref);<#+} else {#>
	ptr->insert(ptr->begin()+index, value);<#+}#>

}

<#=i.ExportI("cppClass*", "data", "")#>
{
	return ptr->data();
}

#ifdef __cplusplus  
}
#endif
<#+ manager.EndBlock(false); } #>