<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	string ClassName;
	string csClass;
	string cppClass;
	string cppVector = null;

	outputClass(manager, "PointIndices", "PointIndices", "PointIndices", new VectorParms
	{
		Includes = new[]{"pcl/PointIndices.h"},
		CppNamespaces = new[]{"pcl"}
	});


	manager.Process(true);
#>
<#+
void outputClass(Manager manager, string ClassName, string csClass, string cppClass, VectorParms parms) 
{
	var classname = ClassName.ToLower();
	var classFunc = "std_vector_" + classname;

	var cppVector = parms.cppVector;

	if (cppVector== null)	
	 cppVector = "vector<"+cppClass+">";

	manager.StartNewFile("VectorOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppVector);
	i.Var("cppClass", cppClass);
	i.Var("cppVector", cppVector);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
<#= string.Join("", parms.Namespaces.Select(s => "using " + s + ";\r\n")) #>

namespace PclSharp.Std
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Func("IntPtr", "ctor_count", "int count") #>
		<#= i.Delete() #>
		<#= i.FuncI("IntPtr", "at", " UIntPtr idx") #>
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("void", "resize", "int size") #>
		<#= i.FuncI("add", "csClass value") #>
		<#= i.FuncI("insert", "IntPtr idx, csClass value") #>
	}

	public unsafe class VectorOf<#= ClassName #> : Vector<<#=csClass#>>
	{	
		private bool _suppressDispose;

		public override int Count => (int)<#=i.InvokeI("size")#>;

		public VectorOf<#= ClassName #>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public VectorOf<#= ClassName #>(int count)
		{
			_ptr = <#=i.Invoke("ctor_count", "count")#>;
		}

		internal VectorOf<#=ClassName#>(IntPtr ptr)
		{
			_suppressDispose = true;
			_ptr = ptr;
		}

		public override void At(int idx, ref <#=csClass#> value)
		{
			throw new NotImplementedException();
		}

		private IntPtr At(int idx)
			=> <#=i.InvokeI("at", "(UIntPtr)idx")#>;

		public override <#=csClass#> this[int idx]
        {
            get { return new <#=csClass#>(At(idx)); }
			set { throw new NotImplementedException(); }
		}

		public override void Resize(int size)
			=> <#=i.InvokeI("resize", "size")#>;

		public override void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "value")#>;

		public override void CopyTo(<#=csClass#>[] arr, int idx)
		{
            throw new NotImplementedException();
		}

		public override <#=csClass#>[] ToArray()
		{
			var arr = new <#=csClass#>[Count];
			for(var i = 0; i < arr.Length; i++)
				arr[i] = new <#=csClass#>(At(i));

			return arr;
		}

		public override void Clear() => <#=i.InvokeI("clear")#>;

		public override void Insert(int index, <#=csClass#> item)
			=> <#=i.InvokeI("insert", "(IntPtr)index, item")#>;

		public override IEnumerator<<#=csClass#>> GetEnumerator()
		{
			var count = Count;
			for(var i = 0; i < count; i++)
				yield return new <#=csClass#>(At(i));
		}

		protected override void DisposeObject()
		{
			if (_suppressDispose)
				return;
			<#= i.DeleteI() #>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\std\\VectorOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"
#include <vector>
<#= string.Join("", parms.Includes.Select(s => "#include \"" + s + "\"\r\n")) #>

using namespace std;
<#= string.Join("", parms.CppNamespaces.Select(s => "using namespace " + s + ";\r\n")) #>

typedef <#= cppVector #> vectorType;

#ifdef __cplusplus  
extern "C" {  
#endif

<#= i.Export("vectorType*", "ctor", "") #>
{
	return new <#=cppVector#>();
}

<#= i.Export("vectorType*", "ctor_count", "int count") #>
{
	return new <#=cppVector#>(count);
}

<#=i.Export("void", "delete", "cppVector** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("cppClass*", "at", "size_t idx")#>
{
	return &ptr->at(idx);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("void", "resize", "int32_t size")#>
{
	ptr->resize(size);
}

<#=i.ExportI("void", "add", "cppClass* value")#>
{
	ptr->push_back(*value);
}

<#=i.ExportI("void", "insert", "ptrdiff_t index, cppClass* value")#>
{
	ptr->insert(ptr->begin()+index, *value);
}

#ifdef __cplusplus  
}
#endif
<#+ manager.EndBlock(false); } #>