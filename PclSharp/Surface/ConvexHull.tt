<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	manager.Process(true);
#>
// Code generated by a template
namespace PclSharp.Surface
{
	public abstract class ConvexHull<PointT> : MeshConstruction<PointT>
	{
		public abstract bool ComputeAreaVolume { set; }
		public abstract double TotalArea { get; }
		public abstract double TotalVolume { get; }
		public abstract int Dimension { get; set; }

		public abstract void GetHullPointIndices(PointIndices indices);
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin)
{ 
	var classname = ClassName.ToLower();
	var classFunc = "surface_convexhull_" + classname;
	
	var cppWrapper = "ConvexHull<"+cppin+">";

	manager.StartNewFile("ConvexHullOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
using PclSharp.Search;

namespace PclSharp.Surface
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>
		//methods
		<#=i.FuncI("setInputCloud", "IntPtr cloud")#>
		<#=i.FuncI("setIndices", "IntPtr indices")#>
		<#=i.FuncI("setSearchMethod", "IntPtr search")#>
		<#=i.FuncI("reconstruct", "IntPtr mesh")#>

		<#=i.FuncI("double", "getTotalArea", "")#>
		<#=i.FuncI("double", "getTotalVolume", "")#>
		<#=i.FuncI("void", "setComputeAreaVolume", "bool value")#>
		<#=i.FuncI("void", "getHullPointIndices", "IntPtr hullIndices")#>
		<#=i.Prop("Dimension", "int")#>
	}

	public class ConvexHullOf<#=ClassName#> : ConvexHull<<#=csin#>>
	{
		public override double TotalArea
			=> <#=i.InvokeI("getTotalArea")#>;

		public override double TotalVolume
			=> <#=i.InvokeI("getTotalVolume")#>;

		public override bool ComputeAreaVolume
		{
			set { <#=i.InvokeI("setComputeAreaVolume", "value")#>; }
		}

		public override int Dimension
		{
			<#=i.InvokeP("Dimension", "int")#>
		}

		public ConvexHullOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public override void SetInputCloud(PointCloud<<#=csin#>> cloud)
			=> <#=i.InvokeI("setInputCloud", "cloud")#>;

		public override void SetIndices(VectorOfInt indices)
			=> <#=i.InvokeI("setIndices", "indices")#>;

		public override ref <#=csin#> this[int idx]
		{
			get { return ref this.Index(idx); }
		}

		public override void SetSearchMethod(Search<<#=csin#>> search)
			=> <#=i.InvokeI("setSearchMethod", "search")#>;

		public override void Reconstruct(PolygonMesh mesh)
			=> <#=i.InvokeI("reconstruct", "mesh")#>;

		public override void GetHullPointIndices(PointIndices indices)
			=> <#=i.InvokeI("getHullPointIndices", "indices")#>;

		protected override void DisposeObject()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\surface\\ConvexHullOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include <pcl/pcl_base.h>
#include <pcl/point_types.h>
#include <pcl/surface/convex_hull.h>

using namespace pcl;
using namespace std;

typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;
typedef boost::shared_ptr<pcl::search::Search<<#=cppin#>>> search_ptr;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("cppPrefix*", "ctor", "")#>
{
	return new <#=cppWrapper#>();
}

<#=i.Export("void", "delete", "cppPrefix** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setInputCloud", "PointCloud<cppin>* cloud")#>
{ ptr->setInputCloud(boost_cloud(boost_cloud(), cloud)); }

<#=i.ExportI("void", "setIndices", "vector<int>* indices")#>
{ ptr->setIndices(boost::shared_ptr<vector<int>>(boost::shared_ptr<vector<int>>(), indices)); }

<#=i.ExportI("void", "setSearchMethod", "pcl::search::Search<cppin>* search")#>
{ ptr->setSearchMethod(search_ptr(search_ptr(), search)); }

<#=i.ExportI("void", "reconstruct", "PolygonMesh* mesh")#>
{ ptr->reconstruct(*mesh); }

<#=i.ExportI("void", "setComputeAreaVolume", "int value")#>
{ ptr->setComputeAreaVolume(value); }

<#=i.ExportI("double", "getTotalArea", "")#>
{ return ptr->getTotalArea(); }

<#=i.ExportI("double", "getTotalVolume", "")#>
{ return ptr->getTotalVolume(); }

<#=i.ExportI("void", "getHullPointIndices", "PointIndices* hullIndices")#>
{ ptr->getHullPointIndices(*hullIndices); }

<#=i.ExportP("Dimension", "int")#>

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); }#>