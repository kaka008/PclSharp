<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@include file="Manager.ttinclude"#>
<#@include file="InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA");
	outputClass(manager, "XYZL", "PointXYZL", "PointXYZL");
	outputClass(manager, "Normal", "Normal", "Normal");
	manager.Process(true);
#>
<#+ void outputClass(Manager manager, string ClassName, string csClass, string cppClass) 
{ 
	var classname = ClassName.ToLower();
	var classFunc = "pointcloud_" + classname;
	
	var cppCloud = "PointCloud<"+cppClass+">";

	manager.StartNewFile("PointCloudOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppCloud);
	i.Var("cppClass", cppClass);
	i.Var("cppCloud", cppCloud);
	i.Var("cppPoint", cppClass);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
using System.Runtime.CompilerServices;

namespace PclSharp
{
	public static partial class Invoke
	{
		//ctor/dctor
		<#= i.Ctor() #>
		<#= i.Func("IntPtr", "ctor_indices", "IntPtr cloud, IntPtr indices") #>
		<#= i.Func("IntPtr", "ctor_wh", "uint width, uint height") #>
		<#= i.Delete() #>
		//methods
		<#= i.FuncI("unsafe csClass*", "at_colrow", "int col, int row") #>
		<#= i.FuncI("clear") #>
		<#= i.FuncI("unsafe void", "add", "csClass* value") #>
		<#= i.FuncI("void", "downsample", "int factor, IntPtr output")#>
		//properties
		<#= i.FuncI("UIntPtr", "size", "") #>
		<#= i.FuncI("IntPtr", "data", "") #>
		<#= i.FuncI("uint", "width", "") #>
		<#= i.FuncI("void", "width_set", "uint width") #>
		<#= i.FuncI("uint", "height", "") #>
		<#= i.FuncI("void", "height_set", "uint height") #>
		<#= i.FuncI("IntPtr", "points", "") #>
		<#=i.Prop("IsDense", "bool")#>
		[return: MarshalAs(UnmanagedType.Bool)]
		<#= i.FuncI("bool", "isOrganized", "") #>
	}

	public unsafe class PointCloudOf<#=ClassName#> : PointCloud<<#=csClass#>>
	{
		private bool _suppressDispose;

		public override int Width 
		{
			get { return (int)<#=i.InvokeI("width")#>; }
			set { <#=i.InvokeI("width_set", "(uint)value")#>; }
		}
		public override int Height 
		{
			get { return (int)<#=i.InvokeI("height")#>; }
			set { <#=i.InvokeI("height_set", "(uint)value")#>; }
		}
		public override bool IsDense
		{
			<#=i.InvokeP("IsDense", "bool")#>
		}
		public override int Count => (int)<#=i.InvokeI("size")#>;
		public int Size => Count;
		public override bool IsOrganized => <#=i.InvokeI("isOrganized")#>;
		public <#=csClass#>* Data => (<#=csClass#>*)<#=i.InvokeI("data")#>;

		private VectorOf<#=ClassName#> _points;
		public override Vector<<#=csClass#>> Points => _points;

		private PointCloudOf<#=ClassName#>(IntPtr ptr)
		{
			_ptr = ptr;
			_points = new VectorOf<#=ClassName#>(<#=i.InvokeI("points")#>);
		}

		internal PointCloudOf<#=ClassName#>(IntPtr ptr, bool suppressDispose)
			:this(ptr)
		{
			_suppressDispose = suppressDispose;
		}

		public PointCloudOf<#=ClassName#>() 
			: this(<#=i.Invoke("ctor")#>)
		{
		}

		public PointCloudOf<#=ClassName#>(int width, int height)
			: this(<#=i.Invoke("ctor_wh", "(uint)width, (uint)height")#>)
		{
		}

		public PointCloudOf<#=ClassName#>(PointCloudOf<#=ClassName#> cloud, Std.VectorOfInt indices)
			:this (<#=i.Invoke("ctor_indices", "cloud.Ptr, indices.Ptr")#>)
		{
		}

		public void Downsample(int factor, PointCloud<<#=csClass#>> output)
			=> <#=i.InvokeI("downsample", "factor, output")#>;

		public override ref <#=csClass#> At(int col, int row)
			=>  ref Unsafe.AsRef<<#=csClass#>>(<#=i.InvokeI("at_colrow", "col, row")#>);

		public override void Add(<#=csClass#> value)
			=> <#=i.InvokeI("add", "&value")#>;

		protected override void DisposeObject()
		{
			if (_suppressDispose)
				return;
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\PclSharp.Extern\\pointcloud\\PointCloudOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"

using namespace pcl;
using namespace std;

typedef vector<<#=cppClass#>, Eigen::aligned_allocator<<#=cppClass#>>> point_vector;

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif  

<#= i.Export("cppCloud*", "ctor", "") #>
{
	return new <#=cppCloud#>();
}

<#= i.Export("cppCloud*", "ctor_wh", "uint32_t width, uint32_t height") #>
{
	return new <#=cppCloud#>(width, height);
}

<#=i.Export("cppCloud*", "ctor_indices", "cppCloud* cloud, vector<int>* indices")#>
{
	if (indices == NULL)
		return new <#=cppCloud#>(*cloud);
	else
		return new <#=cppCloud#>(*cloud, *indices);
}

<#=i.Export("void", "delete", "cppCloud** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("cppClass*", "at_colrow", "int col, int row")#>
{
	return &ptr->at(col, row);
}

<#=i.ExportI("void", "add", "cppClass* value")#>
{
	//the value needs to be aligned to be pushed into the cloud, so do that.
	<#=cppClass#> deref;
	memcpy(&deref, value, sizeof(<#=cppClass#>));
	ptr->push_back(deref);
}

<#=i.ExportI("size_t", "size", "")#>
{
	return ptr->size();
}

<#=i.ExportI("void", "clear", "")#>
{
	ptr->clear();
}

<#=i.ExportI("uint32_t", "width", "")#>
{
	return ptr->width;
}

<#=i.ExportI("void", "width_set", "uint32_t width")#>
{
	ptr->width = width;
}

<#=i.ExportI("uint32_t", "height", "")#>
{
	return ptr->height;
}

<#=i.ExportI("void", "height_set", "uint32_t height")#>
{
	ptr->height = height;
}

<#=i.ExportI("int32_t", "isOrganized", "")#>
{
	return ptr->isOrganized();
}

<#=i.ExportI("point_vector*", "points", "")#>
{
	return &ptr->points;
}

<#=i.ExportI("cppClass*", "data", "")#>
{
	return ptr->points.data();
}

<#=i.ExportI("void", "downsample", "int factor, cppCloud* output")#>
{
	if (output->width != ptr->width/factor ||
		output->height != ptr->height/factor)
	{
		output->resize(ptr->width/factor * ptr->height/factor);
		output->width = ptr->width/factor;
		output->height = ptr->height/factor;
		output->is_dense = ptr->is_dense;
	}

	if (factor == 1)
	{
		output->points = ptr->points;
		return;
	}

	auto ow = output->width;
	auto oh = output->height;
	auto iw = ptr->width;

	auto oarr = output->points.data();
	auto iarr = ptr->points.data();

	for(size_t c = 0; c < ow; c++)
	{
		for(size_t r = 0; r < oh; r++)
		{
			oarr[r * ow + c] = iarr[r * factor * iw + c * factor];
		}
	}
}

<#=i.ExportI("void", "setIsDense", "int value")#>
{ ptr->is_dense = value; }
<#=i.ExportI("int", "getIsDense", "")#>
{ return ptr->is_dense; }

#ifdef __cplusplus  
}
#endif  
<#+ i.Dispose(); manager.EndBlock(false); #>
<#+ } #>