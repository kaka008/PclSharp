// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;

namespace PclSharp.Segmentation
{
	public static partial class Invoke
	{
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern IntPtr segmentation_cpcsegmentation_xyz_ctor();
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_delete(ref IntPtr ptr);

		//methods
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setInputSupervoxels(IntPtr ptr, IntPtr clusters, IntPtr labelAdjacency);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_segment(IntPtr ptr);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_relabelCloud(IntPtr ptr, IntPtr labeledCloud);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setSmoothnessCheck(IntPtr ptr, bool useSmoothness, float voxelRes, float seedRes, float smoothnessThreshold);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_reset(IntPtr ptr);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setCutting(IntPtr ptr, uint maxCuts, uint cuttingMinSegments, float cuttingMinScore, bool locallyConstrained, bool directedCutting, bool cleanCutting);

		//properties
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setConcavityToleranceThreshold(IntPtr ptr, float value);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern float segmentation_cpcsegmentation_xyz_getConcavityToleranceThreshold(IntPtr ptr);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setKFactor(IntPtr ptr, int kfactor);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setMinSegmentSize(IntPtr ptr, int minSegmentSize);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setSanityCheck(IntPtr ptr, bool useSanity);
		[DllImport(Native.DllName, CallingConvention=Native.CallingConvention)]
		public static extern void segmentation_cpcsegmentation_xyz_setRANSACIterations(IntPtr ptr, uint value);
	}

	public class CPCSegmentationOfXYZ : CPCSegmentation<PointXYZ>
	{
		public override float ConcavityToleranceThreshold
		{
			get { return Invoke.segmentation_cpcsegmentation_xyz_getConcavityToleranceThreshold(_ptr); }
            set { Invoke.segmentation_cpcsegmentation_xyz_setConcavityToleranceThreshold(_ptr, value); }
		}

		public override int KFactor 
		{ set { Invoke.segmentation_cpcsegmentation_xyz_setKFactor(_ptr, value); } }

		public override int MinSegmentSize
		{ set { Invoke.segmentation_cpcsegmentation_xyz_setMinSegmentSize(_ptr, value); } }

		public override bool SanityCheck
		{ set { Invoke.segmentation_cpcsegmentation_xyz_setSanityCheck(_ptr, value); } }

		public override uint RANSACIterations
		{ set { Invoke.segmentation_cpcsegmentation_xyz_setRANSACIterations(_ptr, value); } }

		public CPCSegmentationOfXYZ()
		{
			_ptr = Invoke.segmentation_cpcsegmentation_xyz_ctor();
		}

		public override void SetInputSupervoxels(SupervoxelClusters<PointXYZ> clusters, MultiMap<uint, uint> adjacency)
			=> Invoke.segmentation_cpcsegmentation_xyz_setInputSupervoxels(_ptr, clusters, adjacency);

		public override void SetSmoothnessCheck(bool useSmoothness, float voxelRes, float seedRes, float smoothnessThreshold = 0.1f)
			=> Invoke.segmentation_cpcsegmentation_xyz_setSmoothnessCheck(_ptr, useSmoothness, voxelRes, seedRes, smoothnessThreshold);

		public override void Segment()
			=> Invoke.segmentation_cpcsegmentation_xyz_segment(_ptr);

		public override void RelabelCloud(PointCloud<PointXYZL> labeledCloud)
			=> Invoke.segmentation_cpcsegmentation_xyz_relabelCloud(_ptr, labeledCloud);

		public override void Reset()
			=> Invoke.segmentation_cpcsegmentation_xyz_reset(_ptr);

		public override void SetCutting(
			uint maxCuts = 20, 
			uint cuttingMinSegments=0, 
			float cuttingMinScore=0.16f, 
			bool locallyConstrained=true, 
			bool directedCutting=true, 
			bool cleanCutting=false)
			=> Invoke.segmentation_cpcsegmentation_xyz_setCutting(_ptr, maxCuts, cuttingMinSegments, cuttingMinScore, locallyConstrained, directedCutting, cleanCutting);

		protected override void DisposeObject()
		{
			Invoke.segmentation_cpcsegmentation_xyz_delete(ref _ptr);
		}
	}
}
