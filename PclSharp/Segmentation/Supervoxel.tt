<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA");
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	manager.Process(true);
#>
// Code generated by a template
using System;
using PclSharp.Common;
using PclSharp.Search;
using PclSharp.Std;
using PclSharp.Struct;

namespace PclSharp.Segmentation
{
	public abstract class Supervoxel<PointT> : UnmanagedObject
	{
		public abstract Normal Normal { get; set; }
		public abstract PointXYZRGBA Centroid { get; set; }
		public abstract IntPtr Voxels { get; }
		public abstract IntPtr Normals { get; }
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin)
{ 
	var classname = ClassName.ToLower();
	var classFunc = "segmentation_supervoxel_" + classname;
	
	var cppWrapper = "Supervoxel<"+cppin+">";

	manager.StartNewFile("SupervoxelOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
	i.Var("cppWrapper", cppWrapper);
#>
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using PclSharp.Struct;

namespace PclSharp.Segmentation
{
	public static unsafe partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>

		<#=i.FuncI("IntPtr", "getVoxels", "")#>
		<#=i.FuncI("IntPtr", "getNormals", "")#>
		<#=i.Prop("Normal*", "Normal", "ref Normal")#>
		<#=i.Prop("PointXYZRGBA*", "Centroid", "ref PointXYZRGBA")#>
	}

	public class SupervoxelOf<#=ClassName#> : Supervoxel<<#=csin#>>
	{
		private bool _suppressDispose;

		public unsafe override Normal Normal
		{
			<#=i.InvokePP("Normal", "Normal")#>
		}

		public unsafe override PointXYZRGBA Centroid
		{
			<#=i.InvokePP("Centroid", "PointXYZRGBA")#>
		}

		public override IntPtr Voxels
			=> <#=i.InvokeI("getVoxels", "")#>;

		public override IntPtr Normals
			=> <#=i.InvokeI("getNormals", "")#>;

		public SupervoxelOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		internal SupervoxelOf<#=ClassName#>(IntPtr ptr)
		{
			_suppressDispose = true;
			_ptr = ptr;
		}

		protected override void DisposeObject()
		{
			if (_suppressDispose) return;
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\segmentation\\SupervoxelOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\point_types.h"
#include <pcl/segmentation/supervoxel_clustering.h>

using namespace pcl;
using namespace std;

typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("cppWrapper*", "ctor", "")#>
{
	return new <#=cppWrapper#>();
}

<#=i.Export("void", "delete", "cppWrapper** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setNormal", "Normal* value")#>
{ 
	<#=i.Deref("value", "Normal")#>
	ptr->normal_ = deref; 
}
<#=i.ExportI("Normal*", "getNormal", "")#>
{ return &ptr->normal_; }

<#=i.ExportI("PointXYZRGBA*", "getCentroid", "")#>
{ return &ptr->centroid_; }
<#=i.ExportI("void", "setCentroid", "PointXYZRGBA* value")#>
{ 
	<#=i.Deref("value", "PointXYZRGBA")#>
	ptr->centroid_ = deref; 
}

<#=i.ExportI("PointCloud<cppin>*", "getVoxels", "")#>
{ return ptr->voxels_.get(); }

<#=i.ExportI("PointCloud<Normal>*", "getNormals", "")#>
{ return ptr->normals_.get(); }

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); }#>