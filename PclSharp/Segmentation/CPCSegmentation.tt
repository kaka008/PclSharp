<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	manager.Process(true);
#>
// Code generated by a template
using PclSharp.Common;
using PclSharp.Search;
using PclSharp.Std;
using PclSharp.Struct;

namespace PclSharp.Segmentation
{
	public abstract class CPCSegmentation<PointT> : LCCPSegmentation<PointT>
	{
		public abstract void SetCutting(
			uint maxCuts = 20, 
			uint cuttingMinSegments=0, 
			float cuttingMinScore=0.16f, 
			bool locallyConstrained=true, 
			bool directedCutting=true, 
			bool cleanCutting=false);

		public abstract uint RANSACIterations { set; }
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin)
{ 
	var classname = ClassName.ToLower();
	var classFunc = "segmentation_cpcsegmentation_" + classname;
	
	var cppWrapper = "CPCSegmentation<"+cppin+">";

	manager.StartNewFile("CPCSegmentationOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
	i.Var("cppWrapper", cppWrapper);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;

namespace PclSharp.Segmentation
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>

		//methods
		<#=i.FuncI("setInputSupervoxels", "IntPtr clusters, IntPtr labelAdjacency")#>
		<#=i.FuncI("segment", "")#>
		<#=i.FuncI("relabelCloud", "IntPtr labeledCloud")#>
		<#=i.FuncI("setSmoothnessCheck", "bool useSmoothness, float voxelRes, float seedRes, float smoothnessThreshold")#>
		<#=i.FuncI("reset", "")#>
		<#=i.FuncI("setCutting", "uint maxCuts, uint cuttingMinSegments, float cuttingMinScore, bool locallyConstrained, bool directedCutting, bool cleanCutting")#>

		//properties
		<#=i.Prop("ConcavityToleranceThreshold", "float")#>
		<#=i.FuncI("setKFactor", "int kfactor")#>
		<#=i.FuncI("setMinSegmentSize", "int minSegmentSize")#>
		<#=i.FuncI("setSanityCheck", "bool useSanity")#>
		<#=i.FuncI("setRANSACIterations", "uint value")#>
	}

	public class CPCSegmentationOf<#=ClassName#> : CPCSegmentation<<#=csin#>>
	{
		public override float ConcavityToleranceThreshold
		{
			<#=i.InvokeP("ConcavityToleranceThreshold", "float")#>
		}

		public override int KFactor 
		{ set { <#=i.InvokeI("setKFactor", "value")#>; } }

		public override int MinSegmentSize
		{ set { <#=i.InvokeI("setMinSegmentSize", "value")#>; } }

		public override bool SanityCheck
		{ set { <#=i.InvokeI("setSanityCheck", "value")#>; } }

		public override uint RANSACIterations
		{ set { <#=i.InvokeI("setRANSACIterations", "value")#>; } }

		public CPCSegmentationOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor", "")#>;
		}

		public override void SetInputSupervoxels(SupervoxelClusters<<#=csin#>> clusters, MultiMap<uint, uint> adjacency)
			=> <#=i.InvokeI("setInputSupervoxels", "clusters, adjacency")#>;

		public override void SetSmoothnessCheck(bool useSmoothness, float voxelRes, float seedRes, float smoothnessThreshold = 0.1f)
			=> <#=i.InvokeI("setSmoothnessCheck", "useSmoothness, voxelRes, seedRes, smoothnessThreshold")#>;

		public override void Segment()
			=> <#=i.InvokeI("segment", "")#>;

		public override void RelabelCloud(PointCloud<PointXYZL> labeledCloud)
			=> <#=i.InvokeI("relabelCloud", "labeledCloud")#>;

		public override void Reset()
			=> <#=i.InvokeI("reset", "")#>;

		public override void SetCutting(
			uint maxCuts = 20, 
			uint cuttingMinSegments=0, 
			float cuttingMinScore=0.16f, 
			bool locallyConstrained=true, 
			bool directedCutting=true, 
			bool cleanCutting=false)
			=> <#=i.InvokeI("setCutting", "maxCuts, cuttingMinSegments, cuttingMinScore, locallyConstrained, directedCutting, cleanCutting")#>;

		protected override void DisposeObject()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\segmentation\\CPCSegmentationOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\point_types.h"
#include <pcl/segmentation/cpc_segmentation.h>

using namespace pcl;
using namespace std;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("cppWrapper*", "ctor", "")#>
{ return new <#=cppWrapper#>(); }

<#=i.Export("void", "delete", "cppWrapper** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setInputSupervoxels", "map<uint32_t, Supervoxel<cppin>::Ptr>* clusters, multimap< uint32_t, uint32_t >* labelAdjacency")#>
{ ptr->setInputSupervoxels(*clusters, *labelAdjacency); }

<#=i.ExportI("void", "segment", "")#>
{ ptr->segment(); }

<#=i.ExportI("void", "reset", "")#>
{ ptr->reset(); }

<#=i.ExportI("void", "setCutting", "uint32_t maxCuts, uint32_t cuttingMinSegments, float cuttingMinScore, int locallyConstrained, int directedCutting, int cleanCutting")#>
{ ptr->setCutting(maxCuts, cuttingMinSegments, cuttingMinScore, locallyConstrained, directedCutting, cleanCutting); }

<#=i.ExportI("void", "relabelCloud", "PointCloud<PointXYZL>* labeledCloud")#>
{ ptr->relabelCloud(*labeledCloud); }

<#=i.ExportI("void", "setSmoothnessCheck", "int useSmoothness, float voxelRes, float seedRes, float smoothnessThreshold")#>
{ ptr->setSmoothnessCheck(useSmoothness, voxelRes, seedRes, smoothnessThreshold); }

<#=i.ExportP("ConcavityToleranceThreshold", "float")#>

<#=i.ExportI("void", "setKFactor", "int kfactor")#>
{ ptr->setKFactor(kfactor); }

<#=i.ExportI("void", "setMinSegmentSize", "int minSegmentSize")#>
{ ptr->setMinSegmentSize(minSegmentSize); }

<#=i.ExportI("void", "setSanityCheck", "int useSanity")#>
{ ptr->setSanityCheck(useSanity); }

<#=i.ExportI("void", "setRANSACIterations", "uint32_t value")#>
{ ptr->setRANSACIterations(value); }

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); }#>