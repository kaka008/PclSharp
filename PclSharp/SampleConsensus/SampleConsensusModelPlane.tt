<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	//outputClass(manager, "XYZRGBA", "PointXYZRGBA", "PointXYZRGBA");
	manager.Process(true);
#>
// Code generated by a template
namespace PclSharp.SampleConsensus
{
	public abstract class SampleConsensusModelPlane<PointT> : SampleConsensusModel<PointT>
	{
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csClass, string cppClass) 
{ 
	var classname = ClassName.ToLower();
	var classFunc = "sampleconsensusmodel_plane_" + classname;
	
	var cppWrapper = "SampleConsensusModelPlane<"+cppClass+">";

	manager.StartNewFile("SampleConsensusModelPlaneOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csClass, cppWrapper);
	i.Var("cppClass", cppClass);
	i.Var("cppWrapper", cppWrapper);
	i.Var("cppPoint", cppClass);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Eigen;
using PclSharp.Std;

namespace PclSharp.SampleConsensus
{
	public static partial class Invoke
	{
		<#=i.Func("IntPtr", "ctor_indices", "IntPtr cloud, IntPtr indices")#>
		<#=i.Delete()#>

		//methods
		<#=i.FuncI("void", "setInputCloud", "IntPtr cloud")#>
		<#=i.FuncI("void", "setIndices", "IntPtr indices")#>
		<#=i.FuncI("void", "selectWithinDistance", "IntPtr modelCoefficients, double distance, IntPtr inliers")#>
		<#=i.FuncI("void", "getSamples", "int iterations, IntPtr samples")#>
		<#=i.FuncI("void", "optimizeModelCoefficients", "IntPtr inliers, IntPtr modelCoefficients, IntPtr optimizedCoefficients")#>
		<#=i.FuncI("bool", "computeModelCoefficients", "IntPtr samples, IntPtr modelCoefficients")#>
	}

	public class SampleConsensusModelPlaneOf<#=ClassName#> : SampleConsensusModelPlane<<#=csClass#>>
	{
		public SampleConsensusModelPlaneOf<#=ClassName#>(PointCloud<<#=csClass#>> cloud = null, Std.VectorOfInt indices = null)
		{
			_ptr = <#=i.Invoke("ctor_indices", "cloud, indices")#>;
		}

		public override bool ComputeModelCoefficients(VectorOfInt samples, VectorXf modelCoefficients)
			=> <#=i.InvokeI("computeModelCoefficients", "samples, modelCoefficients")#>;

        public override void GetSamples(int iterations, VectorOfInt samples)
        {
            <#=i.InvokeI("getSamples", "iterations, samples.Ptr")#>;
        }

        public override void OptimizeModelCoefficients(VectorOfInt inliers, VectorXf modelCoefficients, VectorXf optimizedCoefficients)
        {
            <#=i.InvokeI("optimizeModelCoefficients", "inliers.Ptr, modelCoefficients, optimizedCoefficients")#>;
        }

        public override void SetIndices(VectorOfInt indices)
        {
            <#=i.InvokeI("setIndices", "indices")#>;
        }

        public override void SetInputCloud(PointCloud<<#=csClass#>> cloud)
        {
            <#=i.InvokeI("setInputCloud", "cloud")#>;
        }

		public override void SelectWithinDistance(VectorXf modelCoefficients, double distance, Std.VectorOfInt inliers)
		{
			<#=i.InvokeI("selectWithinDistance", "modelCoefficients, distance, inliers")#>;
		}

		protected override void DisposeObject()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\sampleconsensus\\SampleConsensusModelPlaneOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include "pcl\sample_consensus\sac_model_plane.h"

using namespace pcl;
using namespace std;

typedef <#= cppWrapper #> sac_plane;
typedef boost::shared_ptr<PointCloud<<#=cppClass#>>> boost_cloud;

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif  

<#= i.Export("cppWrapper*", "ctor_indices", "PointCloud<cppClass>* cloud, vector<int>* indices, bool random") #>
{
	if (indices)
		return new <#=cppWrapper#>(boost_cloud(boost_cloud(), cloud), *indices, random);
	else
		return new <#=cppWrapper#>(boost_cloud(boost_cloud(), cloud), random);
}

<#=i.Export("void", "delete", "cppWrapper** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setIndices", "vector<int>* indices")#>
{ ptr->setIndices(*indices); }

<#=i.ExportI("void", "setInputCloud", "PointCloud<cppClass>* cloud")#>
{ ptr->setInputCloud(boost_cloud(boost_cloud(), cloud)); }

<#=i.ExportI("void", "selectWithinDistance", "Eigen::VectorXf* modelCoefficients, double distance, vector<int>* inliers")#>
{ ptr-> selectWithinDistance(*modelCoefficients, distance, *inliers); }

<#=i.ExportI("void", "getSamples", "int iterations, vector<int>* samples")#>
{
	ptr->getSamples(iterations, *samples);
}

<#=i.ExportI("void", "optimizeModelCoefficients", "vector<int>* inliers, Eigen::VectorXf* modelCoefficients, Eigen::VectorXf* optimizedCoefficients")#>
{
	ptr->optimizeModelCoefficients(*inliers, *modelCoefficients, *optimizedCoefficients);
}

<#=i.ExportI("int", "computeModelCoefficients", "vector<int>* samples, Eigen::VectorXf* modelCoefficients")#>
{ return ptr->computeModelCoefficients(*samples, *modelCoefficients); }

#ifdef __cplusplus  
}
#endif  
<#+ i.Dispose(); manager.EndBlock(false); } #>