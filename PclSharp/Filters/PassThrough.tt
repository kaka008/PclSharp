<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 

	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	manager.Process(true);
#>
// Code generated by a template
namespace PclSharp.Filters
{
	public abstract class PassThrough<PointT> : FilterIndices<PointT>
	{
		public abstract void  SetFilterFieldName(string filterFieldName);
		public abstract string  GetFilterFieldName();
		public abstract bool FilterLimitsNegative { get; set; }
		public abstract void SetFilterLimits(float limit_min,float limit_max);
		public abstract void GetFilterLimits(ref float limit_min,ref float limit_max);
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin)
{ 
	var classname = ClassName.ToLower();
	var classFunc = "filters_passThrough_" + classname;
	
	var cppWrapper = "PassThrough<"+cppin+">";

	manager.StartNewFile("PassThroughOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
using System.Text;
namespace PclSharp.Filters
{
	public static partial class Invoke
	{
		<#= i.Func("IntPtr", "ctor", "[MarshalAs(UnmanagedType.I1)]bool extractRemovedIndices") #>
		<#= i.Delete() #>
		//methods
		<#=i.FuncI("filter", "IntPtr output")#>
		<#=i.FuncI("setInputCloud", "IntPtr cloud")#>
		<#=i.FuncI("setIndices", "IntPtr indices")#>
		<#=i.FuncI("setFilterLimits", "float limit_min,float limit_max")#>
		<#=i.FuncI("getFilterLimits", "ref float limit_min,ref float limit_max")#>
		<#=i.FuncI("setFilterFieldName", "string filterFieldname")#>
		<#=i.FuncStr("string","getFilterFieldName", "")#> 


		//properties
		<#=i.Prop("KeepOrganized", "bool")#>
		<#=i.Prop("Negative", "bool")#>
		<#=i.Prop("FilterLimitsNegative", "bool")#>
	}

	public class PassThroughOf<#=ClassName#> : PassThrough<<#=csin#>>
	{

		public override bool FilterLimitsNegative
		{
			<#=i.InvokeP("FilterLimitsNegative", "bool")#>
		}

		public override bool Negative
		{
			<#=i.InvokeP("Negative", "bool")#>
		}

		public override bool KeepOrganized
		{
			<#=i.InvokeP("KeepOrganized", "bool")#>
		}

		public PassThroughOf<#=ClassName#>(bool extractRemovedIndices = false)
		{
			_ptr = <#=i.Invoke("ctor", "extractRemovedIndices")#>;
		}

		public override void SetInputCloud(PointCloud<<#=csin#>> cloud)
		{
			<#=i.InvokeI("setInputCloud", "cloud")#>;
		}

		public override void filter(PointCloud<<#=csin#>> output)
		{
			<#=i.InvokeI("filter", "output.Ptr")#>;
		}

		public override void SetIndices(VectorOfInt indices)
		{
			<#=i.InvokeI("setIndices", "indices")#>;
		}
		public override void SetFilterLimits(float limit_min,float limit_max)
		{
			<#=i.InvokeI("setFilterLimits", "limit_min,limit_max")#>;
		}
		public override void GetFilterLimits(ref float limit_min,ref float limit_max)
		{
			<#=i.InvokeI("getFilterLimits", "ref limit_min,ref limit_max")#>;
		}

		public override void SetFilterFieldName(string filterFieldName)
		{
			<#=i.InvokeI("setFilterFieldName", "filterFieldName")#>;
		}
		public override string GetFilterFieldName()
		{  		     			
		    return	<#=i.InvokeI("getFilterFieldName", "")#>;
		}


		public override ref <#=csin#> this[int idx]
		{
			get { return ref this.Index(idx); }
		}

		protected override void DisposeObject()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\filters\\PassThroughOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include <pcl/filters/passthrough.h>
#include <comdef.h>
#include <comutil.h>

using namespace pcl;
using namespace std;

typedef <#=cppWrapper#> filter_t;
typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("filter_t*", "ctor", "bool extractRemovedIndices")#>
{
	return new filter_t(extractRemovedIndices);
}

<#=i.Export("void", "delete", "filter_t** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "filter", "PointCloud<cppin>* output")#>
{
	ptr->filter(*output);
}

<#=i.ExportI("void", "setInputCloud", "PointCloud<cppin>* cloud")#>
{
	ptr->setInputCloud(boost_cloud(boost_cloud(), cloud));
}

<#=i.ExportI("void", "setIndices", "vector<int>* indices")#>
{
	ptr->setIndices(boost::shared_ptr<vector<int>>(boost::shared_ptr<vector<int>>(), indices));
}
<#=i.ExportI("void", "setFilterLimits", "float limit_min,float limit_max")#>
{
	ptr->setFilterLimits(limit_min,limit_max);
}
<#=i.ExportI("void", "getFilterLimits", "float &limit_min,float &limit_max")#>
{
	ptr->getFilterLimits(limit_min,limit_max);
}
<#=i.ExportI("void", "setFilterFieldName", "char *filterFieldName")#>
{
	ptr->setFilterFieldName(filterFieldName);
}
<#=i.ExportI("BSTR", "getFilterFieldName", "")#>
{
    return  _com_util::ConvertStringToBSTR(ptr->getFilterFieldName().c_str());
}


/*<#=i.ExportP("FilterFieldName", "string")#>*/

<#=i.ExportP("FilterLimitsNegative", "bool")#>

<#=i.ExportP("KeepOrganized", "int")#>

<#=i.ExportP("Negative", "int")#>

#ifdef __cplusplus  
}
#endif  
<#+ i.Dispose(); manager.EndBlock(false); }#>