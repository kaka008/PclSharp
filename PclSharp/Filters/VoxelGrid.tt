<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ");
	manager.Process(true);
#>
// Code generated by a template
namespace PclSharp.Filters
{
	public abstract class VoxelGrid<PointT> : Filter<PointT>
	{
		public abstract (double min, double max) FilterLimits { get; set; }
		public abstract string FilterFieldName { get; set; }
		public abstract bool DownsampleAllData { get; set; }
		public abstract int MinimumPointsNumberPerVoxel { get; set; }
		public abstract Eigen.Vector3i MinBoxCoordinates { get; }
		public abstract Eigen.Vector3i MaxBoxCoordinates { get; }
		public abstract Eigen.Vector3i NrDivisions { get; }
		public abstract Eigen.Vector3i DivisionMultiplier { get; }
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin)
{ 
	var classname = ClassName.ToLower();
	var classFunc = "filters_voxelGrid_" + classname;
	
	var cppWrapper = "VoxelGrid<"+cppin+">";

	manager.StartNewFile("VoxelGridOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
namespace PclSharp.Filters
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>
		//methods
		<#=i.FuncI("filter", "IntPtr output")#>
		<#=i.FuncI("setInputCloud", "IntPtr cloud")#>
		<#=i.FuncI("setIndices", "IntPtr indices")#>

		//properties
		<#=i.FuncI("PointXYZ", "getLeafSize", "")#>
		<#=i.FuncI("void", "setLeafSize", "PointXYZ size")#>
		
		<#=i.FuncI("void", "setFilterFieldName", "string name")#>
		<#=i.FuncI("void", "getFilterFieldName", "IntPtr str, int dstSz")#>
		
		<#=i.FuncI("void", "getFilterLimits", "ref double min, ref double max")#>
		<#=i.FuncI("void", "setFilterLimits", "double min, double max")#>

		<#=i.Prop("DownsampleAllData", "bool") #>
		<#=i.Prop("MinimumPointsNumberPerVoxel", "int")#>

		<#=i.FuncI("Eigen.Vector3i", "getMinBoxCoordinates", "")#>
		<#=i.FuncI("Eigen.Vector3i", "getMaxBoxCoordinates", "")#>
		<#=i.FuncI("Eigen.Vector3i", "getNrDivisions", "")#>
		<#=i.FuncI("Eigen.Vector3i", "getDivisionMultiplier", "")#>
	}

	public class VoxelGridOf<#=ClassName#> : VoxelGrid<<#=csin#>>
	{
		public PointXYZ LeafSize
		{
			get { return <#=i.InvokeI("getLeafSize")#>; }
			set { <#=i.InvokeI("setLeafSize", "value")#>; }
		}

		public override Eigen.Vector3i MinBoxCoordinates
			=> <#=i.InvokeI("getMinBoxCoordinates")#>;

		public override Eigen.Vector3i MaxBoxCoordinates
			=> <#=i.InvokeI("getMaxBoxCoordinates")#>;

		public override Eigen.Vector3i NrDivisions
			=> <#=i.InvokeI("getNrDivisions")#>;

		public override Eigen.Vector3i DivisionMultiplier
			=> <#=i.InvokeI("getDivisionMultiplier")#>;

		public override (double min, double max) FilterLimits
		{
			get
			{
				var min = double.MaxValue; var max = double.MinValue;
				<#=i.InvokeI("getFilterLimits", "ref min, ref max")#>;
				return (min, max);
			}
			set { <#=i.InvokeI("setFilterLimits", "value.min, value.max")#>; }
		}

		public unsafe override string FilterFieldName
		{
			get 
			{
				byte* str = stackalloc byte[16];
				<#=i.InvokeI("getFilterFieldName", "(IntPtr)str, 15")#>;
				str[15] = 0; //just in case the string was too long and they didn't write the null terminator.
				return Marshal.PtrToStringAnsi((IntPtr)str);
			}
			set { <#=i.InvokeI("setFilterFieldName", "value")#>; }
		}

		public override bool DownsampleAllData
		{
			<#=i.InvokeP("DownsampleAllData", "bool")#>
		}

		public override int MinimumPointsNumberPerVoxel
		{
			<#=i.InvokeP("MinimumPointsNumberPerVoxel", "int")#>
		}

		public VoxelGridOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public override void SetInputCloud(PointCloud<<#=csin#>> cloud)
		{
			<#=i.InvokeI("setInputCloud", "cloud")#>;
		}

		public override void SetIndices(VectorOfInt indices)
		{
			<#=i.InvokeI("setIndices", "indices")#>;
		}

		public override void filter(PointCloud<<#=csin#>> output)
		{
			<#=i.InvokeI("filter", "output.Ptr")#>;
		}

		public override ref <#=csin#> this[int idx]
		{
			get { return ref this.Index(idx); }
		}

		protected override void DisposeObject()
		{
			<#=i.DeleteI()#>;
		}
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\filters\\VoxelGridOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include <pcl/filters/voxel_grid.h>

using namespace pcl;
using namespace std;

typedef <#=cppWrapper#> voxel_grid;
typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("voxel_grid*", "ctor", "")#>
{
	return new voxel_grid();
}

<#=i.Export("void", "delete", "voxel_grid** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "filter", "PointCloud<cppin>* output")#>
{
	ptr->filter(*output);
}

<#=i.ExportI("void", "setInputCloud", "PointCloud<cppin>* cloud")#>
{
	ptr->setInputCloud(boost_cloud(boost_cloud(), cloud));
}

<#=i.ExportI("void", "setIndices", "vector<int>* indices")#>
{
	ptr->setIndices(boost::shared_ptr<vector<int>>(boost::shared_ptr<vector<int>>(), indices));
}

<#=i.ExportI("PointXYZ", "getLeafSize", "")#>
{
	auto size = ptr->getLeafSize();
	return PointXYZ(size[0], size[1], size[2]);
}

<#=i.ExportI("void", "setLeafSize", "PointXYZ size")#>
{
	ptr->setLeafSize(Eigen::Vector4f(size.x, size.y, size.z, 1));
}

<#=i.ExportI("void", "setFilterFieldName", "const char* str")#>
{ ptr->setFilterFieldName(string(str)); }

<#=i.ExportI("void", "getFilterFieldName", "char* str, int dstSz")#>
{ strcpy_s(str, dstSz, ptr->getFilterFieldName().c_str()); }

<#=i.ExportI("void", "getFilterLimits", "double* min, double* max")#>
{ ptr->getFilterLimits(*min, *max); }

<#=i.ExportI("void", "setFilterLimits", "double min, double max")#>
{ ptr->setFilterLimits(min, max); }

<#=i.ExportP("DownsampleAllData", "int")#>

<#=i.ExportP("MinimumPointsNumberPerVoxel", "int")#>

<#=i.ExportI("Eigen::Vector3i", "getMinBoxCoordinates", "")#>
{ return ptr->getMinBoxCoordinates(); }

<#=i.ExportI("Eigen::Vector3i", "getMaxBoxCoordinates", "")#>
{ return ptr->getMaxBoxCoordinates(); }

<#=i.ExportI("Eigen::Vector3i", "getNrDivisions", "")#>
{ return ptr->getNrDivisions(); }

<#=i.ExportI("Eigen::Vector3i", "getDivisionMultiplier", "")#>
{ return ptr->getDivisionMultiplier(); }

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); }#>