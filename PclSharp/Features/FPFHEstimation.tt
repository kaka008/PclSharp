<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<#
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ", "Normal", "Normal");
	manager.Process(true);
#>
// Code generated by a template
using PclSharp.Struct;

namespace PclSharp.Features
{
	public abstract class FPFHEstimation<PointT, PointNT> : FeatureFromNormals<PointT, PointNT, FPFHSignature33>
	{
		public abstract (int f1, int f2, int f3) NrSubdivisions { get; set; }
	}
}
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin, string csout, string cppout)
{ 
	ClassName = cppin + "And" + cppout;
	var classname = ClassName.ToLower();
	var classFunc = "features_fpfhestimation_" + classname;
	
	var cppWrapper = "FPFHEstimation<"+cppin+", "+cppout+", FPFHSignature33>";

	manager.StartNewFile("FPFHEstimationOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
	i.Var("cppout", cppout);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;

namespace PclSharp.Features
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>

		<#= i.FuncI("setInputCloud", "IntPtr cloud")#>
		<#= i.FuncI("setInputNormals", "IntPtr normals")#>
		<#= i.FuncI("setIndices", "IntPtr indices")#>
		<#= i.FuncI("compute", "IntPtr cloud")#>

		<#=i.Prop("KSearch", "int")#>
		<#=i.Prop("RadiusSearch", "double")#>

		<#=i.FuncI("getNrSubdivisions", "ref int f1, ref int f2, ref int f3")#>
		<#=i.FuncI("setNrSubdivisions", "int f1, int f2, int f3")#>
	}

	public class FPFHEstimationOf<#=ClassName#> : FPFHEstimation<<#=csin#>, <#=csout#>>
	{
		public override (int f1, int f2, int f3) NrSubdivisions 
		{
			get
			{
				int f1 = 0;
				int f2 = 0;
				int f3 = 0;
				<#=i.InvokeI("getNrSubdivisions", "ref f1, ref f2, ref f3")#>;
				return (f1, f2, f3);
			}
			set { <#=i.InvokeI("setNrSubdivisions", "value.f1, value.f2, value.f3")#>; }
		}

		public override int KSearch 
		{ 
			<#=i.InvokeP("KSearch", "int")#> 
		}

        public override double RadiusSearch 
		{ 
			<#=i.InvokeP("RadiusSearch", "int")#> 
		}

		public FPFHEstimationOf<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public override void SetInputCloud(PointCloud<<#=csin#>> cloud) 
			=> <#=i.InvokeI("setInputCloud", "cloud.Ptr")#>;

		public override void SetIndices(VectorOfInt indices)
			=> <#=i.InvokeI("setIndices", "indices")#>;

		public override ref <#=csin#> this[int idx]
		{
			get { return ref this.Index(idx); }
		}

		public override void Compute(PointCloud<FPFHSignature33> cloud) 
			=> <#=i.InvokeI("compute", "cloud.Ptr")#>;

		public override void SetInputNormals(PointCloud<<#=csout#>> normals)
			=> <#= i.InvokeI("setInputNormals", "normals")#>;

		protected override void DisposeObject()
			=> <#=i.DeleteI()#>;
	}
}
<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\features\\FPFHEstimationOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include <pcl/features/fpfh.h>

using namespace pcl;
using namespace std;

typedef <#=cppWrapper#> cpp_wrapper;
typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;
typedef boost::shared_ptr<PointCloud<<#=cppout#>>> boost_norms;
typedef boost::shared_ptr<vector<int>> boost_indices;

#ifdef __cplusplus
extern "C" {
#endif 

<#=i.Export("cpp_wrapper*", "ctor", "")#>
{
	return new <#=cppWrapper#>();
}

<#=i.Export("void", "delete", "cpp_wrapper** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#= i.ExportI("void", "setInputCloud", "PointCloud<cppin>* cloud")#>
{ ptr->setInputCloud(boost_cloud(boost_cloud(), cloud)); }

<#= i.ExportI("void", "setIndices", "std::vector<int>* indices")#>
{ ptr->setIndices(boost_indices(boost_indices(), indices)); }

<#= i.ExportI("void", "compute", "PointCloud<FPFHSignature33>* cloud")#>
{ ptr->compute(*cloud); }

<#= i.ExportI("void", "setInputNormals", "PointCloud<cppout>* normals")#>
{ ptr->setInputNormals(boost_norms(boost_norms(), normals)); }

<#=i.ExportP("KSearch", "int")#>
<#=i.ExportP("RadiusSearch", "double")#>

<#=i.ExportI("void", "getNrSubdivisions", "int* f1, int* f2, int* f3")#>
{ ptr->getNrSubdivisions(*f1, *f2, *f3); }
<#=i.ExportI("void", "setNrSubdivisions", "int f1, int f2, int f3")#>
{ ptr->setNrSubdivisions(f1, f2, f3); }

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); }#>