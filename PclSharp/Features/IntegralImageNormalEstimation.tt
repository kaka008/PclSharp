<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
<#@include file="..\Manager.ttinclude"#>
<#@include file="..\InvokeTemplate.ttinclude"#>
<# 
	var manager = Manager.Create(Host, GenerationEnvironment);
	outputClass(manager, "XYZ", "PointXYZ", "PointXYZ", "Normal", "Normal");
	manager.Process(true);
#>
<#+ void outputClass(Manager manager, string ClassName, string csin, string cppin, string csout, string cppout)
{ 
	ClassName = cppin + "And" + cppout;
	var classname = ClassName.ToLower();
	var classFunc = "features_integralImageNormalEstimation_" + classname;
	
	var cppWrapper = "IntegralImageNormalEstimation<"+cppin+", "+cppout+">";

	manager.StartNewFile("IntegralImageNormalEstimationOf"+ClassName+".generated.cs");
	var i = new InvokeT(classFunc, csin, cppWrapper);
	i.Var("cppin", cppin);
	i.Var("cppout", cppout);
#>
// Code generated by a template
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Runtime.InteropServices;
using PclSharp.Struct;
using PclSharp.Std;
using static PclSharp.Features.IntegralImageNormalEstimation;

namespace PclSharp.Features
{
	public static partial class Invoke
	{
		<#= i.Ctor() #>
		<#= i.Delete() #>
		<#= i.FuncI("setRectSize", "int width, int height")#>
		<#= i.FuncI("setBorderPolicy", "BorderPolicy policy")#>
		<#= i.FuncI("setNormalEstimationMethod", "NormalEstimationMethod method")#>
		<#= i.FuncI("setMaxDepthChangeFactor", "float factor")#>
		<#= i.FuncI("setNormalSmoothingSize", "float size")#>
		<#= i.FuncI("setInputCloud", "IntPtr cloud")#>
		<#= i.FuncI("setIndices", "IntPtr indices")#>
		<#= i.FuncI("compute", "IntPtr cloud")#>

		<#=i.Prop("KSearch", "int")#>
		<#=i.Prop("RadiusSearch", "double")#>
	}

	public class IntegralImageNormalEstimation<#=ClassName#> : IntegralImageNormalEstimation<<#=csin#>,<#=csout#>>
	{
		public override int KSearch 
		{ 
			<#=i.InvokeP("KSearch", "int")#> 
		}

        public override double RadiusSearch 
		{ 
			<#=i.InvokeP("RadiusSearch", "int")#> 
		}

		public IntegralImageNormalEstimation<#=ClassName#>()
		{
			_ptr = <#=i.Invoke("ctor")#>;
		}

		public override void SetRectSize(int width, int height) 
			=> <#=i.InvokeI("setRectSize", "width, height")#>;

		public override void SetBorderPolicy(BorderPolicy policy) 
			=> <#=i.InvokeI("setBorderPolicy", "policy")#>;

		public override void SetNormalEstimationMethod(NormalEstimationMethod method) 
			=> <#=i.InvokeI("setNormalEstimationMethod", "method")#>;

		public override void SetMaxDepthChangeFactor(float factor) 
			=> <#=i.InvokeI("setMaxDepthChangeFactor", "factor")#>;

		public override void SetNormalSmoothingSize(float size) 
			=> <#=i.InvokeI("setNormalSmoothingSize", "size")#>;

		public override void SetInputCloud(PointCloud<<#=csin#>> cloud) 
			=> <#=i.InvokeI("setInputCloud", "cloud.Ptr")#>;

		public override void SetIndices(VectorOfInt indices)
			=> <#=i.InvokeI("setIndices", "indices")#>;

		public override void Compute(PointCloud<<#=csout#>> cloud) 
			=> <#=i.InvokeI("compute", "cloud.Ptr")#>;

		public override ref <#=csin#> this[int idx]
		{
			get { return ref this.Index(idx); }
		}

		protected override void DisposeObject()
			=> <#=i.DeleteI()#>;
	}
}

<#+ 
	manager.EndBlock(); 
	manager.StartNewFile("..\\..\\PclSharp.Extern\\features\\IntegralImageNormalEstimationOf"+ClassName+".generated.cpp");
#>
// Code generated by a template
#pragma once
#include "..\export.h"

#include "pcl\pcl_base.h"
#include "pcl\point_types.h"
#include <pcl/features/integral_image_normal.h>

using namespace pcl;
using namespace std;

typedef <#=cppWrapper#> integral_image;
typedef boost::shared_ptr<PointCloud<<#=cppin#>>> boost_cloud;
typedef boost::shared_ptr<vector<int>> boost_indices;

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif 

<#=i.Export("integral_image*", "ctor", "")#>
{
	return new integral_image();
}

<#=i.Export("void", "delete", "integral_image** ptr")#>
{
	delete *ptr;
	*ptr = NULL;
}

<#=i.ExportI("void", "setRectSize", "int width, int height")#>
{
	ptr->setRectSize(width, height);
}
<#=i.ExportI("void", "setBorderPolicy", "integral_image::BorderPolicy policy")#>
{
	ptr->setBorderPolicy(policy);
}
<#=i.ExportI("void", "setNormalEstimationMethod", "integral_image::NormalEstimationMethod method")#>
{
	ptr->setNormalEstimationMethod(method);
}
<#= i.ExportI("void", "setMaxDepthChangeFactor", "float factor")#>
{
	ptr->setMaxDepthChangeFactor(factor);
}
<#= i.ExportI("void", "setNormalSmoothingSize", "float size")#>
{
	ptr->setNormalSmoothingSize(size);
}

<#= i.ExportI("void", "setInputCloud", "PointCloud<cppin>* cloud")#>
{ ptr->setInputCloud(boost_cloud(boost_cloud(), cloud)); }

<#= i.ExportI("void", "setIndices", "std::vector<int>* indices")#>
{ ptr->setIndices(boost_indices(boost_indices(), indices)); }

<#= i.ExportI("void", "compute", "PointCloud<cppout>* cloud")#>
{ ptr->compute(*cloud); }

<#=i.ExportP("KSearch", "int")#>
<#=i.ExportP("RadiusSearch", "double")#>

#ifdef __cplusplus  
}
#endif  
<#+	i.Dispose(); manager.EndBlock(false); #>
<#+ } #>